/*
  Programmer:       Mohammad Seeam
  Topic:            Search, sort algorithm with performance comparison
*/

#include <random> // for srand, rand
#include <iostream>
#include <iomanip>

using namespace std;

// The searching and sorting algorithms will be tested on a big array filled with random numbers.
// To test on various array sizes, increasing amounts of the big array will be used.
// A table will display results of how long it takes to complete a task on various sizes of test data.
const int BIGSIZE = 64000;
int bigArray[BIGSIZE];
const int testSizes[] = {1000, 2000, 4000, 8000, 16000, 32000, BIGSIZE, 0}; // 0 is a sentinel
// All numbers inside testSizes MUST BE less than or equal to BIGSIZE

const int TARGET = -54321; // TARGET used as a number to search for.
// TARGET cannot be found. It is not in the range of 0 - 2 ^ 16 -1 which is output by rand()
// generated by rand(), as desired to test for worst-case performance of search.

// array helper functions:
void show_array(int array[], int size, const string &msg="") { // displays every element in array
  cout<<msg;
  for (int i=0; i<size; ++i)
    cout << setw(2) << array[i]; // assumes small numbers
  cout << endl;
}

// Useful to verify that array is really sorted!
bool verifySorted(int array[], int size) {
  // returns true if array is in ascending order, else false.
  for (int i=0; i<(size-1); ++i)
    if (array[i]>array[i+1]) return false;
  return true;
}


// Useful to measure unsorted-ness of the array
int unorderedCount(int array[], int size) {
  // returns count of out-of-order adjacent pairs; will be 0 if properly sorted.
  int unsorted_adjacent_pairs=0;
  for (int i=0; i<(size-1); ++i)
    if (array[i]>array[i+1]) ++unsorted_adjacent_pairs;
  return unsorted_adjacent_pairs;
}

// To display the table of timing results, use these to set column widths:
const int AlgorithmNameMaxWidth=16; // maximum column width to display algorithm names
const int TestSizeWidth=12;         // maximum column width to display time to run algorithms
const int DurationWidth=TestSizeWidth;
// Adjust these column widths if/as needed so the table columns are aligned.

// Each selection sort below does the same algorithm. The difference is in
// how well it documents its operation. See code after main.
const string SELECTION_SORT_NAME="selection sort";
void selection_sort_concise(int[], int);   // from internet, not called
void selection_sort_textbook(int[], int);  // from our textbook, not called
void selection_sort(int[], int, bool);    // as expected for this lab

// <modify code> Change "my_sort_1", "my_sort_2" to better names that match sort algorithm
const string SORT1_NAME ="bubble sort";
void my_sort_1(int[], int, bool);    // expected for this lab <modify code>

const string SORT2_NAME ="insertion sort";
void my_sort_2(int[], int, bool);    // expected for this lab <modify code>

bool linear_search_array(int [], int, int, int&); // provided
int binary_search_array(int [], int, int, int&); // expected for this lab <modify code>

// This code helps to automate multiple test runs.

// Call this code as many times as desired to test your sort algorithms.
float testSortAlgorithm1x(void sortAlgorithm(int [], int, bool), int array[], int arraySize, bool verbose=false) {
  // Run sortAlgorithm once on array and return time elapsed in milliseconds.
  // This function is interesting. The first parameter is a "function pointer",
  // It accepts any function that returns a void and has parameters of type: (int [], int, bool)
  // The first parameter (in the caller) can be the name of a function being tested.
  // This reduces redundant code. The same sequence of tests are performed on each
  // sort function. (Our textbook does not mention function pointers.)
  
  // fill array with random, unsorted numbers to be sorted
  for (int index = 0; index < arraySize; index++){
    array[index] = rand();  // initialize array with random values
  }

  int startTime = clock();  // get the start time, in milliseconds
  sortAlgorithm(array, arraySize, verbose);  // ALGORITHM UNDER TEST
  int stopTime = clock();   // get the stop time, in milliseconds
  float duration = stopTime - startTime;
  
  int unordered_pairs = unorderedCount(array, arraySize);
  if (unordered_pairs != 0)
    return -unordered_pairs; // return a negative count of unordered pairs to indicate sort failure
  else
    return duration;
}

void testSortAlgorithmNx(void sortAlgorithm(int [], int, bool), string sortName, int array[], int arraySize, bool verbose=false) {
  // call testSortAlgorithm1x for each size in testSizes; display results on one line of table
  cout << endl << setw (AlgorithmNameMaxWidth) << left << sortName;
  
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testSortAlgorithm1x(sortAlgorithm, array, testSizes[testCount]);
}
                        

// Copy/paste/modify/reuse this code as desired to test search algorithms.
// Because search is much faster than sort and duration is in milliseconds,
// the search is run retry times (defaults to 1000) and duration is divided by retry.
float testLinearSearch(int array[], int arraySize, int retry=1000) {
  bool found = false; // true if TARGET is found in array
  int foundAt = -1;    // index in array where TARGET was found
  int startTime = clock();
  for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
    found = linear_search_array(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
  int stopTime = clock();
  float duration = stopTime - startTime;
  return duration/retry; // divide duration by 1000 to get time for single search
}

// <new code> to test binary search. It works like testLinearSearch
float testBinarySearch(int array[], int arraySize, int retry=1000) {
  // <new code> to return the duration of performing a binary search
  // You can reuse the code for testLinearSearch, but call binary_search_array
  // Your parameters to call binarySeachArray may be different than linear_search_array.
  bool found = false; // true if TARGET is found in array
  int foundAt = -1;    // index in array where TARGET was found
  int startTime = clock();
  for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
    found = binary_search_array(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
  int stopTime = clock();
  float duration = stopTime - startTime;
  return duration/retry; // divide duration by 1000 to get time for single search
  return 0.0;
}

void testAlgorithms(int array[], int arraySize, bool verbose=false) {
  // Draws a table of results for each algorithm tested.
  // Initially, the heading for the table is displayed:
  cout << setw (AlgorithmNameMaxWidth) << left << "Algorithm";
  for (int testCount=0; testSizes[testCount]; ++testCount)
    cout << setw(TestSizeWidth) << right << testSizes[testCount];
  cout << endl << string(AlgorithmNameMaxWidth, '=');
  for (int testCount=0; testSizes[testCount]; ++testCount)
    cout << setw(DurationWidth) << right << " =======";

  // In testSortAlgorithmNx, the name of the sort function is passed as a parameter.
  // Do the same thing for your sort algorithms. It works as long as your sort algorithm
  // returns void and is declared as: void sort(int array[], int size).
  
  testSortAlgorithmNx(selection_sort, SELECTION_SORT_NAME, array, arraySize); // provided
  // call to test your first sort algorithm. <modify code> rename my sort 1
  testSortAlgorithmNx(my_sort_1, SORT1_NAME, array, arraySize);
  // call to test your second sort algorithm. <modify code> rename my sort 2
  testSortAlgorithmNx(my_sort_2, SORT2_NAME, array, arraySize);

  cout<<"\n--------"; // separator between sort algorithms and search algorithms
  
  // Here, the provided linear search is tested...
  cout << endl << setw (AlgorithmNameMaxWidth) << left << "linear search";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testLinearSearch(array, testSizes[testCount]);

  // <modify code> Use a loop to call and test your search algorithm here
  cout << endl << setw (AlgorithmNameMaxWidth) << left << "binary search";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testBinarySearch(array, testSizes[testCount]);
  cout << endl;
}


void testSortOnSmallArray(void sortAlgorithm(int [], int, bool), string sortName) {
  int smallArray[] = {7, 9, 3, 1, 8, 6, 2}; // for testing purposes

  const int SMALLSIZE = sizeof(smallArray)/sizeof(smallArray[0]);
  
  show_array(smallArray, SMALLSIZE, sortName + " start: smallArray is: ");
  sortAlgorithm(smallArray, SMALLSIZE, true); // true means verbose, show details
  show_array(smallArray, SMALLSIZE, sortName + " stop:  smallArray is: ");
  cout << ((verifySorted(smallArray, SMALLSIZE)) ?
    "Verified: smallArray is sorted.\n\n" :
    "Oops!!!: smallArray is NOT sorted.\n\n");
}

int main () {
  srand(time(0));  // seed the random number generator only once.

  // When first implementing your algorithm, test it on a very small array.
  // The verbose flag will be set to true in testSortOnSmallArray, so step-by-step
  // progress will be displayed. This describes how the sort is working.

  cout << "Test sorting algorithms on small array:\n\n";
  // testSortOnSmallArray provides a small array to test on and sets verbose=true
  testSortOnSmallArray(selection_sort, SELECTION_SORT_NAME);
  testSortOnSmallArray(my_sort_1, SORT1_NAME);
  testSortOnSmallArray(my_sort_2, SORT2_NAME);

  
  // After sort code works on small array, test performance on bigArray.
  float duration = 0.0; // time in milliseconds
  // Startup code performs a single test run using the full size of bigArray
  duration = testSortAlgorithm1x(selection_sort, bigArray, BIGSIZE);
  cout << fixed << setprecision(2);
  cout << "\nSelection sort on bigArray took: "
       << setw(7) << duration << " milliseconds." << endl;
  duration = testLinearSearch(bigArray, BIGSIZE);
  cout << "Linear search of bigArray took: "
       << setw(7) << duration << " milliseconds.\n\n";

  // Test the algorithms on many ever longer list of numbers. Only one array is needed.
  //  Lengths of 1000, 2000, 4000, 8000, 16000, 32000, 64000 are tested and displayed.
  testAlgorithms(bigArray, BIGSIZE);


  return 0;


} // end of main

// Add 2 sorts of your own. Document which sort you implemented
// <new code> Add your first sort algorithm in here
  
void swap(int *xp, int *yp)
{
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}
  
// An optimized version of Bubble Sort
void my_sort_1(int array[], int size, bool verbose=false)
{
   int i, j, totalSwapCount;
   for (i = 0; i < size-1; i++)
   {
     for (j = 0; j < size-i-1; j++)
     {
        if (array[j] > array[j+1])
        {
           if (verbose){
             cout << "Swapping index " << j << " and " << (j+1) << endl;
             totalSwapCount++;
           }
           //swap(&array[j], &array[j+1]);
           int temp = array[j];
           array[j] = array[j+1];
           array[j+1] = temp;

        }
     }
   }
    if (verbose){
      cout << "Total number of Swaps Needed: " << totalSwapCount << endl;
    }
  }
 




// <new code> Add your second sort algorithm in here




/* Function to sort an array using insertion sort*/

void my_sort_2(int array[], int size, bool verbose=false)
{
    int i, key, j;
    for (i = 1; i < size; i++)
    {
        key = array[i];
        j = i - 1;
 
        /* Move elements of arr[0..i-1], that are
        greater than key, to one position ahead
        of their current position */
        while (j >= 0 && array[j] > key)
        {
            if (verbose){
             cout << "Swapping index " << j << " and " << (j+1) << endl;
            }
            array[j + 1] = array[j];
            j = j - 1;

        }
        array[j + 1] = key;
    }
}
 
// A utility function to print an array of size n
void printArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
}


// Your new search algorithm isn't linear search - which is provided here.
bool linear_search_array(int array[], int size, int target, int &position) {
  for (int offset = 0; offset < size; ++offset)
    if (array[offset] == target) // found it!
      {position=offset; return true;}
  position = -1;
  return false;
}

int binary_search_array(int array[], int size, int target, int &position) {
  // Your binary search does not have to have exactly the same declaration
  // but it should include: array, size, target
  // doesn't do anything! <new code>
  int low=0;
  int high=size-1;
  int mid;
  while(low<=high){
    mid=(low+high)/2;
    if (target==array[mid]){
      return mid;
    }else if(target>array[mid]){
      low=mid+1;
    }else{
      high=mid-1;
    }
  }
  return -1;
}

// This is a selection sort from a concise algorithm encyclopedia.
// This code is VERY CRYPTIC! Not useful for learning. Not called.
// If your algorithms look like this, you will lose points!!!
void selection_sort_concise(int array[], int size) {
  int i, idx, val;
  for (i = 0; i < (size - 1); i++) {
    idx = i;
    val = array[i];
    for (int j = i + 1; j < size; j++) {
      if (array[j] < val) {
        val = array[j];
        idx = j;
      }
    }
    array[idx] = array[i];
    array[i] = val;
  }
}

// Your new sort algorithm cannot be selection sort, which is provided.
// This is the selection sort from our textbook, not called.
void selection_sort_textbook(int array[], int size) {
  int startScan, minIndex, minValue;
  for (startScan = 0; startScan < (size - 1); startScan++) {
    minIndex = startScan;
    minValue = array[startScan];
    for (int index = startScan + 1; index < size; index++) {
      if (array[index] < minValue) {
        minValue = array[index];
        minIndex = index;
      }
    }
    array[minIndex] = array[startScan];
    array[startScan] = minValue;
  }
}

// selection sort described in great detail. Do this for your code.
// The verbose option / flag causes a detailed display of its operation for each pass.
void selection_sort(int array[], int size, bool verbose=false) {  //int, double, string, char, bool _ use or dont use &
  int minIndexSoFar = 0, minValueSoFar=array[0];
  for (int unsortedIndex = 0; unsortedIndex < (size - 1); unsortedIndex++) {
    // The outer loop looks at unsorted data, which is initially the whole array.
    // Gradually, a smaller and smaller portion of the array remains unsorted.
    minIndexSoFar = unsortedIndex;
    minValueSoFar = array[unsortedIndex];
    for (int seekMinIndex = unsortedIndex + 1; seekMinIndex < size; seekMinIndex++) {
      // the inner loop seeks the smallest value possible in the remaining unsorted portion of the array.
     if (array[seekMinIndex] < minValueSoFar) { // found a smaller min value than before, save it for now
        if (verbose) cout << "  prev min in array[" << minIndexSoFar << "]=" << minValueSoFar;
        minValueSoFar = array[seekMinIndex];
        minIndexSoFar = seekMinIndex;
        if (verbose) {
          cout << "; new min in array[" << minIndexSoFar << "]=" << minValueSoFar << endl;
        }
      }
    } // The smallest value in the unsorted portion of the array was found.

    if (verbose) {
      cout << "  swap left in array[" << unsortedIndex << "]=" << array[unsortedIndex];
      cout << " with min in array[" << minIndexSoFar << "]=" << array[minIndexSoFar] << endl;
    }

    // Swap original left-most unsorted value with minimum value just found.
    array[minIndexSoFar] = array[unsortedIndex];
    array[unsortedIndex] = minValueSoFar;

    if (verbose) {
      cout << "After pass " << unsortedIndex << ", array is: ";
      show_array(array, size);
      cout << endl;
    }
    // ... continue seeking the minimum value in the smaller remaining portion.
  }
}

/* 
TEST OUTPUT:
Test sorting algorithms on small array:

selection sort start: smallArray is:  7 9 3 1 8 6 2
  prev min in array[0]=7; new min in array[2]=3
  prev min in array[2]=3; new min in array[3]=1
  swap left in array[0]=7 with min in array[3]=1
After pass 0, array is:  1 9 3 7 8 6 2

  prev min in array[1]=9; new min in array[2]=3
  prev min in array[2]=3; new min in array[6]=2
  swap left in array[1]=9 with min in array[6]=2
After pass 1, array is:  1 2 3 7 8 6 9

  swap left in array[2]=3 with min in array[2]=3
After pass 2, array is:  1 2 3 7 8 6 9

  prev min in array[3]=7; new min in array[5]=6
  swap left in array[3]=7 with min in array[5]=6
After pass 3, array is:  1 2 3 6 8 7 9

  prev min in array[4]=8; new min in array[5]=7
  swap left in array[4]=8 with min in array[5]=7
After pass 4, array is:  1 2 3 6 7 8 9

  swap left in array[5]=8 with min in array[5]=8
After pass 5, array is:  1 2 3 6 7 8 9

selection sort stop:  smallArray is:  1 2 3 6 7 8 9
Verified: smallArray is sorted.

bubble sort start: smallArray is:  7 9 3 1 8 6 2
Swapping index 1 and 2
Swapping index 2 and 3
Swapping index 3 and 4
Swapping index 4 and 5
Swapping index 5 and 6
Swapping index 0 and 1
Swapping index 1 and 2
Swapping index 3 and 4
Swapping index 4 and 5
Swapping index 0 and 1
Swapping index 2 and 3
Swapping index 3 and 4
Swapping index 2 and 3
Swapping index 1 and 2
Total number of Swaps Needed: 15
bubble sort stop:  smallArray is:  1 2 3 6 7 8 9
Verified: smallArray is sorted.

insertion sort start: smallArray is:  7 9 3 1 8 6 2
Swapping index 1 and 2
Swapping index 0 and 1
Swapping index 2 and 3
Swapping index 1 and 2
Swapping index 0 and 1
Swapping index 3 and 4
Swapping index 4 and 5
Swapping index 3 and 4
Swapping index 2 and 3
Swapping index 5 and 6
Swapping index 4 and 5
Swapping index 3 and 4
Swapping index 2 and 3
Swapping index 1 and 2
insertion sort stop:  smallArray is:  1 2 3 6 7 8 9
Verified: smallArray is sorted.


Selection sort on bigArray took: 4335363.00 milliseconds.
Linear search of bigArray took:  134.50 milliseconds.

Algorithm               1000        2000        4000        8000       16000       32000       64000
================     =======     =======     =======     =======     =======     =======     =======
selection sort       1119.00     4533.00    17078.00    67613.00   268908.00  1075742.00  4295313.00
bubble sort          1399.00     5461.00    21314.00    90138.00   488808.00  2202655.00  9242267.00
insertion sort        621.00     2339.00     9295.00    37439.00   148862.00   594061.00  2376355.00
--------
linear search           2.13        4.35        8.44       16.77       33.56       67.16      134.08
binary search           0.06        0.06        0.07        0.07        0.08        0.08        0.10
*/
